МЕТОДЫ  JAVA
=========================

Виды спецификаторов
--------------
%d: целочисленных значений
%x: для вывода шестнадцатеричных чисел
%f: для вывода чисел с плавающей точкой
%e: для вывода чисел в экспоненциальной форме, например, 3.1415e+01
%c: для вывода одиночного символа
%s: для вывода строковых значений

количество знаков после запятой
-----------------------------
float ppi = 3.1415f;
System.out.printf("%f\n", pi);    // 3,141500
System.out.printf("%.2f\n", pi);  // 3,14
System.out.printf("%.3f\n", pi);  // 3,141

СТРОКИ:
========================== 
concat(): объединение строк
valueOf(): преобразует Object в строковое представление (завязан на toString())
join(): объединяет набор строк в одну с учетом разделителя
charAt(): получение символа по индексу
indexOf(): первый индекс вхождения подстроки
lastIndexOf(): последний индекс вхождения подстроки
startsWith()/endsWith(): определяет, начинается/заканчивается ли строка с подстроки
replace(): замена одной подстроки на другую
trim(): удаляет начальные и конечные пробелы
substring(): возвращает подстроку, см.аргументы
toLowerCase() / toUpperCase(): возвращает новую строку в нижнем / верхнем регистре
сompareTo(): сравнивает две строки
equals(): сравнивает строки с учетом регистра
equalsIgnoreCase(): сравнивает строки без учета регистра
regionMatches(): сравнивает подстроки в строках

РАБОТА С ФАЙЛОВОЙ СИСТЕМОЙ:
=================================
isHidden(): возвращает истину, если каталог или файл является скрытым
length(): возвращает размер файла в байтах
lastModified(): возвращает время последнего изменения файла или каталога
list(): возвращает массив файлов и подкаталогов, которые находятся в каталоге
listFiles(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
mkdir(): создает новый каталог
renameTo(File dest): переименовывает файл или каталог

КОЛЛЕКЦИИ. ФУНКЦИОНАЛ:
==============================
add(args) – добавляет элемент в список ( в т.ч. на нужную позицию)
get(pos) – возвращает элемент из списка по указанной позиции
indexOf(item) – первое вхождение или -1
lastIndexOf(item) – последнее вхождение или -1
remove(pos) – удаление элемента на указанной позиции и его возвращение
set(int pos, T item) – gjvtoftn значение item элементу, который находится на позиции pos
void sort(Comparator) – сортирует набор данных по правилу
subList(int start, int end) – получение набора данных от позиции start до end
clear() – очистка списка
toString() – «конвертация» списка в строку
Arrays.asList – преобразует массив в список
containsAll(col) – проверяет включение всех элементов из col
removeAll(col) – удаляет элементы, имеющиеся в col
retainAll(col) – оставляет элементы, имеющиеся в col
toArray() – конвертация списка в массив Object’ов
toArray(type array) – конвертация списка в массив type
List.copyOf(col) – возвращает копию списка на основе имеющегося
List.of(item1, item2,...) – возвращает неизменяемый список



// String[] origArray = {"Apple", "", "Cat", "Dog", "", null};
// String[] cleanedArray = Arrays.stream(firstArray).filter(Objects::nonNull).toArray(String[]::new);


HashMap
=======================
put(K,V) – добавить пару если или изменить значение,если ключ имеется.
putIfAbsent(K,V) – произвести добавление если ключ не найден.
get(K) - получение значения по указанному ключу.
remove(K) – удаляет пару по указанному ключу.
containsValue(V) – проверка наличия значения.
containsKey(V) – проверка наличия ключа.
keySet() – возвращает множество ключей.
values() – возвращает набор значений.

TreeMap 
=====================
put(K,V) 
get(K)
remove(K)
descendingKeySet(V)
descendingMap()
tailMap()
lastEntry()
firstEntry()
В основе данной коллекции лежат красно-чёрное деревья. Позволяют быстрее искать, но могут возникнуть «заминки» при добавлении.

HashSet 
===========================
isEmpty() – проверка на пустоту. 
add(V) – добавление элемента в коллекцию. 
remove(V) – удаление элемента из коллекцию. 
contains(V) – проверка на включение элемента в коллекции. 
clear() – удаление всех элементов коллекции. 
size() – возвращает количество элементов коллекции. 

============
книгф Майкла Моргана "Руководство разработчика". Хорошо описывает объектно-ориентированный анализ.
=============


ПЕРЕОПРЕДЕЛЕНИЕ – меняем поведение, к-е было до нас (н-р: в методе переделываем сущность под себя 
=>	@override – обязательно.



ПЕРЕГРУЗКА – значит, что описываем для одной сущности методы с отличающейся сигнатурой (сигнатура – это набор типов). 
Н-р: меняется кол-во аргументов или их тип данных. 
У нас 2 метода distance: в одном 4 координаты, в др. 2 точки в аргументах метода. (пример из 1й лекции по ООП и 7й по java)

=======================



